"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/evvm.ts":
/*!*********************!*\
  !*** ./lib/evvm.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_PAYMENT_TOKEN: function() { return /* binding */ BASE_PAYMENT_TOKEN; },\n/* harmony export */   CONTRACT_FALLBACK: function() { return /* binding */ CONTRACT_FALLBACK; },\n/* harmony export */   DEFAULT_METADATA: function() { return /* binding */ DEFAULT_METADATA; },\n/* harmony export */   DEFAULT_RESOLVER: function() { return /* binding */ DEFAULT_RESOLVER; },\n/* harmony export */   EVVM_ADDRESS: function() { return /* binding */ EVVM_ADDRESS; },\n/* harmony export */   EVVM_ID: function() { return /* binding */ EVVM_ID; },\n/* harmony export */   NAME_SUFFIX: function() { return /* binding */ NAME_SUFFIX; },\n/* harmony export */   RELAYER_URL: function() { return /* binding */ RELAYER_URL; },\n/* harmony export */   ZERO_ADDRESS: function() { return /* binding */ ZERO_ADDRESS; },\n/* harmony export */   checkRelayerHealth: function() { return /* binding */ checkRelayerHealth; },\n/* harmony export */   createGaslessRegistration: function() { return /* binding */ createGaslessRegistration; },\n/* harmony export */   createGaslessRenewal: function() { return /* binding */ createGaslessRenewal; },\n/* harmony export */   createGaslessTransfer: function() { return /* binding */ createGaslessTransfer; },\n/* harmony export */   generateServiceNonce: function() { return /* binding */ generateServiceNonce; },\n/* harmony export */   getEvvmID: function() { return /* binding */ getEvvmID; },\n/* harmony export */   getNextNonce: function() { return /* binding */ getNextNonce; },\n/* harmony export */   isServiceNonceUsed: function() { return /* binding */ isServiceNonceUsed; },\n/* harmony export */   sendToRelayer: function() { return /* binding */ sendToRelayer; },\n/* harmony export */   signEvvmPay: function() { return /* binding */ signEvvmPay; },\n/* harmony export */   signServiceFunction: function() { return /* binding */ signServiceFunction; },\n/* harmony export */   signTransactionRequest: function() { return /* binding */ signTransactionRequest; },\n/* harmony export */   verifyContractHasUpdatedFunction: function() { return /* binding */ verifyContractHasUpdatedFunction; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _contracts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contracts */ \"(app-pages-browser)/./lib/contracts.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../node_modules/process/browser.js\");\n\n\nconst EVVM_ADDRESS = \"0xfc99769602914d649144f6b2397e2aa528b2878d\" || 0;\nconst EVVM_ID = process.env.NEXT_PUBLIC_EVVM_ID || \"1047\";\nconst RELAYER_URL = process.env.NEXT_PUBLIC_RELAYER_URL || \"http://localhost:3001\";\n/**\n * Checks if the relayer service is available\n */ async function checkRelayerHealth(relayerUrl) {\n    try {\n        const response = await fetch(\"\".concat(relayerUrl, \"/health\"), {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            return {\n                available: false,\n                error: \"Relayer returned status \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            available: data.status === \"healthy\"\n        };\n    } catch (error) {\n        return {\n            available: false,\n            error: error.message || \"Failed to connect to relayer\"\n        };\n    }\n}\n/**\n * Signs an EVVM payment transaction\n * Message format: \"<evvmID>,pay,<toAddress>,<token>,<amount>,<priorityFee>,<nonce>,<priorityFlag>,<executor>\"\n */ async function signEvvmPay(signer, evvmID, toAddress, token, amount, priorityFee, nonce, priorityFlag, executor) {\n    // Format matches EVVM contract: addressToString converts to lowercase without 0x prefix\n    // But actually, let's use the address directly as the contract does\n    // The contract uses: _receiverAddress == address(0) ? _receiverIdentity : AdvancedStrings.addressToString(_receiverAddress)\n    // Since we're using an address (not identity), we use the address\n    // AdvancedStrings.addressToString likely converts to lowercase hex without 0x\n    // But for now, let's use the address as-is (lowercase) to match\n    const formatAddress = (addr)=>addr.toLowerCase();\n    const inputs = \"\".concat(formatAddress(toAddress), \",\").concat(formatAddress(token), \",\").concat(amount.toString(), \",\").concat(priorityFee.toString(), \",\").concat(nonce.toString(), \",\").concat(priorityFlag ? \"true\" : \"false\", \",\").concat(formatAddress(executor));\n    const message = \"\".concat(evvmID, \",pay,\").concat(inputs);\n    const messageBytes = ethers__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes(message);\n    const signature = await signer.signMessage(messageBytes);\n    return signature;\n}\n/**\n * Signs a service function call\n * Message format: \"<evvmID>,<functionName>,<params>\"\n */ async function signServiceFunction(signer, evvmID, functionName, params) {\n    const message = \"\".concat(evvmID, \",\").concat(functionName, \",\").concat(params);\n    const messageBytes = ethers__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes(message);\n    const signature = await signer.signMessage(messageBytes);\n    return signature;\n}\n/**\n * Generates a random nonce for service functions (async nonce)\n * Uses timestamp + random number to ensure uniqueness\n */ function generateServiceNonce() {\n    const timestamp = BigInt(Date.now());\n    const random = BigInt(Math.floor(Math.random() * 1000000));\n    return timestamp * BigInt(1000000) + random;\n}\n/**\n * Creates gasless registration data with both service and EVVM payment signatures\n */ async function createGaslessRegistration(signer, evvmID, name, duration, resolver, metadata, amount, priorityFee, contractAddress, provider, evvmAddress) {\n    const userAddress = await signer.getAddress();\n    // 1. Generate service nonce (async nonce - can be any unused number)\n    const serviceNonce = generateServiceNonce();\n    // 2. Create service signature\n    // Format: \"<evvmID>,registerGasless,<name>,<duration>,<amount>,<nonce>\"\n    const serviceParams = \"\".concat(name, \",\").concat(duration.toString(), \",\").concat(amount.toString(), \",\").concat(serviceNonce.toString());\n    const serviceSignature = await signServiceFunction(signer, evvmID, \"registerGasless\", serviceParams);\n    // 3. Get EVVM payment nonce (sync nonce - must be sequential)\n    const evvmNonce = await getNextNonce(provider, evvmAddress, userAddress);\n    // 4. Create EVVM payment signature\n    const evvmSignature = await signEvvmPay(signer, evvmID, contractAddress, \"0x0000000000000000000000000000000000000001\", amount, priorityFee, evvmNonce, false, contractAddress);\n    return {\n        functionName: \"registerGasless\",\n        args: [\n            name,\n            duration,\n            resolver,\n            metadata,\n            userAddress,\n            amount,\n            serviceNonce,\n            serviceSignature,\n            priorityFee,\n            evvmNonce,\n            false,\n            evvmSignature\n        ]\n    };\n}\n/**\n * Creates gasless renewal data with both service and EVVM payment signatures\n */ async function createGaslessRenewal(signer, evvmID, nameHash, duration, amount, priorityFee, contractAddress, provider, evvmAddress) {\n    const userAddress = await signer.getAddress();\n    // 1. Generate service nonce\n    const serviceNonce = generateServiceNonce();\n    // 2. Create service signature\n    // Format: \"<evvmID>,renewGasless,<nameHash>,<duration>,<amount>,<nonce>\"\n    const serviceParams = \"\".concat(nameHash, \",\").concat(duration.toString(), \",\").concat(amount.toString(), \",\").concat(serviceNonce.toString());\n    const serviceSignature = await signServiceFunction(signer, evvmID, \"renewGasless\", serviceParams);\n    // 3. Get EVVM payment nonce\n    const evvmNonce = await getNextNonce(provider, evvmAddress, userAddress);\n    // 4. Create EVVM payment signature\n    const evvmSignature = await signEvvmPay(signer, evvmID, contractAddress, \"0x0000000000000000000000000000000000000001\", amount, priorityFee, evvmNonce, false, contractAddress);\n    return {\n        functionName: \"renewGasless\",\n        args: [\n            nameHash,\n            duration,\n            userAddress,\n            amount,\n            serviceNonce,\n            serviceSignature,\n            priorityFee,\n            evvmNonce,\n            false,\n            evvmSignature\n        ]\n    };\n}\n/**\n * Creates gasless transfer data with service signature\n */ async function createGaslessTransfer(signer, evvmID, nameHash, newOwner, contractAddress) {\n    const userAddress = await signer.getAddress();\n    // 1. Generate service nonce\n    const serviceNonce = generateServiceNonce();\n    // 2. Create service signature\n    // Format: \"<evvmID>,transferGasless,<nameHash>,<newOwner>,<nonce>\"\n    const serviceParams = \"\".concat(nameHash, \",\").concat(newOwner, \",\").concat(serviceNonce.toString());\n    const serviceSignature = await signServiceFunction(signer, evvmID, \"transferGasless\", serviceParams);\n    return {\n        functionName: \"transferGasless\",\n        args: [\n            nameHash,\n            newOwner,\n            userAddress,\n            serviceNonce,\n            serviceSignature\n        ]\n    };\n}\n/**\n * Gets the next sync nonce for EVVM payments\n */ async function getNextNonce(provider, evvmAddress, userAddress) {\n    const evvmAbi = [\n        \"function getNextCurrentSyncNonce(address user) view returns (uint256)\"\n    ];\n    const evvmContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.Contract(evvmAddress, evvmAbi, provider);\n    return evvmContract.getNextCurrentSyncNonce(userAddress);\n}\n/**\n * Gets the EVVM ID (returns as string for compatibility)\n */ async function getEvvmID(provider, evvmAddress) {\n    // Try uint256 first (new format), fallback to string (old format)\n    try {\n        const evvmAbi = [\n            \"function getEvvmID() view returns (uint256)\"\n        ];\n        const evvmContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.Contract(evvmAddress, evvmAbi, provider);\n        const id = await evvmContract.getEvvmID();\n        // Return the ID as string, even if it's 0\n        // Note: EVVM ID of 0 means the contract hasn't been registered\n        return id.toString();\n    } catch (e) {\n        // Fallback to string format for older contracts\n        try {\n            const evvmAbi = [\n                \"function getEvvmID() view returns (string)\"\n            ];\n            const evvmContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.Contract(evvmAddress, evvmAbi, provider);\n            const id = await evvmContract.getEvvmID();\n            return id;\n        } catch (e) {\n            // If all else fails, return \"0\" as default (matches contract behavior)\n            // This indicates the EVVM contract hasn't been registered\n            return \"0\";\n        }\n    }\n}\n/**\n * Checks if a service nonce has been used\n */ async function isServiceNonceUsed(provider, contractAddress, userAddress, nonce) {\n    const abi = [\n        \"function isServiceNonceUsed(address user, uint256 nonce) view returns (bool)\"\n    ];\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.Contract(contractAddress, abi, provider);\n    return contract.isServiceNonceUsed(userAddress, nonce);\n}\n/**\n * Verifies that the contract has the updated registerGasless function\n * Returns true if the contract has the new signature, false otherwise\n */ async function verifyContractHasUpdatedFunction(provider, contractAddress) {\n    try {\n        // Try to call the new function signature with estimateGas\n        // This will fail if the function doesn't exist or has wrong signature\n        const abi = [\n            \"function registerGasless(string name, uint256 duration, address resolver, string metadata, address user, uint256 amount, uint256 nonce, bytes signature, uint256 priorityFee_EVVM, uint256 nonce_EVVM, bool priorityFlag_EVVM, bytes signature_EVVM)\"\n        ];\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.Contract(contractAddress, abi, provider);\n        // Try to estimate gas with dummy parameters\n        // If the function exists, this will work (even if it reverts for other reasons)\n        try {\n            await contract.registerGasless.estimateGas(\"test\", BigInt(365 * 24 * 60 * 60), ethers__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress, \"{}\", ethers__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress, BigInt(0), BigInt(0), \"0x\", BigInt(0), BigInt(0), false, \"0x\");\n            return {\n                hasUpdatedFunction: true\n            };\n        } catch (err) {\n            // If it's a signature mismatch, the function doesn't exist\n            if ((err === null || err === void 0 ? void 0 : err.code) === \"CALL_EXCEPTION\" && (err === null || err === void 0 ? void 0 : err.data) === null) {\n                return {\n                    hasUpdatedFunction: false,\n                    error: \"Contract does not have the updated registerGasless function. Please redeploy the contract with the new code.\"\n                };\n            }\n            // Other errors (like revert) mean the function exists but failed for other reasons\n            return {\n                hasUpdatedFunction: true\n            };\n        }\n    } catch (err) {\n        return {\n            hasUpdatedFunction: false,\n            error: \"Failed to verify contract: \".concat((err === null || err === void 0 ? void 0 : err.message) || \"Unknown error\")\n        };\n    }\n}\n/**\n * Signs a transaction request for the relayer\n * This signature proves the user authorized sending this transaction to the relayer\n * Format: \"<userAddress>,<contractAddress>,<functionName>,<argsHash>,<nonce>\"\n */ async function signTransactionRequest(signer, userAddress, contractAddress, functionName, args, nonce) {\n    // Create a message that includes all transaction details\n    // Convert args to a consistent format for hashing\n    const normalizedArgs = args.map((arg)=>{\n        if (typeof arg === \"bigint\") {\n            return arg.toString();\n        }\n        return arg;\n    });\n    const argsHash = ethers__WEBPACK_IMPORTED_MODULE_4__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes(JSON.stringify(normalizedArgs)));\n    const message = \"\".concat(userAddress, \",\").concat(contractAddress, \",\").concat(functionName, \",\").concat(argsHash, \",\").concat(nonce.toString());\n    const messageBytes = ethers__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes(message);\n    const signature = await signer.signMessage(messageBytes);\n    return signature;\n}\n/**\n * Sends transaction to relayer service\n * The relayer will submit the transaction on behalf of the user (paying gas)\n */ async function sendToRelayer(relayerUrl, userAddress, contractAddress, functionName, args, serviceNonce, signer) {\n    // Sign the transaction request for relayer validation\n    const signature = await signTransactionRequest(signer, userAddress, contractAddress, functionName, args, serviceNonce);\n    const response = await fetch(\"\".concat(relayerUrl, \"/api/submit\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            userAddress,\n            contractAddress,\n            functionName,\n            args: args.map((arg)=>{\n                // Convert bigint to string for JSON serialization\n                if (typeof arg === \"bigint\") {\n                    return arg.toString();\n                }\n                return arg;\n            }),\n            signature,\n            nonce: serviceNonce.toString()\n        })\n    });\n    if (!response.ok) {\n        const errorData = await response.json().catch(()=>({\n                error: response.statusText\n            }));\n        throw new Error(\"Relayer error: \".concat(errorData.error || response.statusText));\n    }\n    const data = await response.json();\n    if (!data.success) {\n        throw new Error(\"Relayer error: \".concat(data.error || \"Transaction submission failed\"));\n    }\n    return data.txHash;\n}\nconst DEFAULT_METADATA = JSON.stringify({\n    type: \"healthcare-provider\",\n    specialty: \"general\"\n});\nconst DEFAULT_RESOLVER = ethers__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress;\nconst ZERO_ADDRESS = ethers__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress;\nconst NAME_SUFFIX = \".motus\";\nconst BASE_PAYMENT_TOKEN = \"0x0000000000000000000000000000000000000001\";\nconst CONTRACT_FALLBACK = _contracts__WEBPACK_IMPORTED_MODULE_0__.CONTRACT_ADDRESS;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTUyxJQUFJO0lBQ2hDLElBQUksQ0FBQ0QsS0FBS29GLE9BQU8sRUFBRTtRQUNqQixNQUFNLElBQUlELE1BQU0sa0JBQWdFLE9BQTlDbkYsS0FBS0YsS0FBSyxJQUFJO0lBQ2xEO0lBRUEsT0FBT0UsS0FBS3FGLE1BQU07QUFDcEI7QUFFTyxNQUFNQyxtQkFBbUJWLEtBQUtDLFNBQVMsQ0FBQztJQUM3Q1UsTUFBTTtJQUNOQyxXQUFXO0FBQ2IsR0FBRTtBQUVLLE1BQU1DLG1CQUFtQjdHLCtDQUFrQjtBQUMzQyxNQUFNOEcsZUFBZTlHLCtDQUFrQjtBQUN2QyxNQUFNK0csY0FBYyxTQUFRO0FBQzVCLE1BQU1DLHFCQUFxQiw2Q0FBNEM7QUFDdkUsTUFBTUMsb0JBQW9CaEgsd0RBQWdCQSxDQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9ldnZtLnRzPzQ5ODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJ1xuaW1wb3J0IHsgQ09OVFJBQ1RfQUREUkVTUyB9IGZyb20gJy4vY29udHJhY3RzJ1xuXG5leHBvcnQgY29uc3QgRVZWTV9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRVZWTV9BRERSRVNTIHx8ICcweGZjOTk3Njk2MDI5MTRkNjQ5MTQ0ZjZiMjM5N2UyYWE1MjhiMjg3OGQnXG5leHBvcnQgY29uc3QgRVZWTV9JRCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0VWVk1fSUQgfHwgJzEwNDcnXG5leHBvcnQgY29uc3QgUkVMQVlFUl9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19SRUxBWUVSX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJ1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcmVsYXllciBzZXJ2aWNlIGlzIGF2YWlsYWJsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tSZWxheWVySGVhbHRoKHJlbGF5ZXJVcmw6IHN0cmluZyk6IFByb21pc2U8eyBhdmFpbGFibGU6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3JlbGF5ZXJVcmx9L2hlYWx0aGAsIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICB9KVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHJldHVybiB7IGF2YWlsYWJsZTogZmFsc2UsIGVycm9yOiBgUmVsYXllciByZXR1cm5lZCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4geyBhdmFpbGFibGU6IGRhdGEuc3RhdHVzID09PSAnaGVhbHRoeScgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgcmV0dXJuIHsgYXZhaWxhYmxlOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBjb25uZWN0IHRvIHJlbGF5ZXInIH1cbiAgfVxufVxuXG4vKipcbiAqIFNpZ25zIGFuIEVWVk0gcGF5bWVudCB0cmFuc2FjdGlvblxuICogTWVzc2FnZSBmb3JtYXQ6IFwiPGV2dm1JRD4scGF5LDx0b0FkZHJlc3M+LDx0b2tlbj4sPGFtb3VudD4sPHByaW9yaXR5RmVlPiw8bm9uY2U+LDxwcmlvcml0eUZsYWc+LDxleGVjdXRvcj5cIlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkV2dm1QYXkoXG4gIHNpZ25lcjogZXRoZXJzLlNpZ25lcixcbiAgZXZ2bUlEOiBzdHJpbmcsXG4gIHRvQWRkcmVzczogc3RyaW5nLFxuICB0b2tlbjogc3RyaW5nLFxuICBhbW91bnQ6IGJpZ2ludCxcbiAgcHJpb3JpdHlGZWU6IGJpZ2ludCxcbiAgbm9uY2U6IGJpZ2ludCxcbiAgcHJpb3JpdHlGbGFnOiBib29sZWFuLFxuICBleGVjdXRvcjogc3RyaW5nXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAvLyBGb3JtYXQgbWF0Y2hlcyBFVlZNIGNvbnRyYWN0OiBhZGRyZXNzVG9TdHJpbmcgY29udmVydHMgdG8gbG93ZXJjYXNlIHdpdGhvdXQgMHggcHJlZml4XG4gIC8vIEJ1dCBhY3R1YWxseSwgbGV0J3MgdXNlIHRoZSBhZGRyZXNzIGRpcmVjdGx5IGFzIHRoZSBjb250cmFjdCBkb2VzXG4gIC8vIFRoZSBjb250cmFjdCB1c2VzOiBfcmVjZWl2ZXJBZGRyZXNzID09IGFkZHJlc3MoMCkgPyBfcmVjZWl2ZXJJZGVudGl0eSA6IEFkdmFuY2VkU3RyaW5ncy5hZGRyZXNzVG9TdHJpbmcoX3JlY2VpdmVyQWRkcmVzcylcbiAgLy8gU2luY2Ugd2UncmUgdXNpbmcgYW4gYWRkcmVzcyAobm90IGlkZW50aXR5KSwgd2UgdXNlIHRoZSBhZGRyZXNzXG4gIC8vIEFkdmFuY2VkU3RyaW5ncy5hZGRyZXNzVG9TdHJpbmcgbGlrZWx5IGNvbnZlcnRzIHRvIGxvd2VyY2FzZSBoZXggd2l0aG91dCAweFxuICAvLyBCdXQgZm9yIG5vdywgbGV0J3MgdXNlIHRoZSBhZGRyZXNzIGFzLWlzIChsb3dlcmNhc2UpIHRvIG1hdGNoXG4gIGNvbnN0IGZvcm1hdEFkZHJlc3MgPSAoYWRkcjogc3RyaW5nKSA9PiBhZGRyLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgaW5wdXRzID0gYCR7Zm9ybWF0QWRkcmVzcyh0b0FkZHJlc3MpfSwke2Zvcm1hdEFkZHJlc3ModG9rZW4pfSwke2Ftb3VudC50b1N0cmluZygpfSwke3ByaW9yaXR5RmVlLnRvU3RyaW5nKCl9LCR7bm9uY2UudG9TdHJpbmcoKX0sJHtwcmlvcml0eUZsYWcgPyAndHJ1ZScgOiAnZmFsc2UnfSwke2Zvcm1hdEFkZHJlc3MoZXhlY3V0b3IpfWBcbiAgY29uc3QgbWVzc2FnZSA9IGAke2V2dm1JRH0scGF5LCR7aW5wdXRzfWBcbiAgY29uc3QgbWVzc2FnZUJ5dGVzID0gZXRoZXJzLnRvVXRmOEJ5dGVzKG1lc3NhZ2UpXG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduTWVzc2FnZShtZXNzYWdlQnl0ZXMpXG4gIHJldHVybiBzaWduYXR1cmVcbn1cblxuLyoqXG4gKiBTaWducyBhIHNlcnZpY2UgZnVuY3Rpb24gY2FsbFxuICogTWVzc2FnZSBmb3JtYXQ6IFwiPGV2dm1JRD4sPGZ1bmN0aW9uTmFtZT4sPHBhcmFtcz5cIlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnblNlcnZpY2VGdW5jdGlvbihcbiAgc2lnbmVyOiBldGhlcnMuU2lnbmVyLFxuICBldnZtSUQ6IHN0cmluZyxcbiAgZnVuY3Rpb25OYW1lOiBzdHJpbmcsXG4gIHBhcmFtczogc3RyaW5nXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBtZXNzYWdlID0gYCR7ZXZ2bUlEfSwke2Z1bmN0aW9uTmFtZX0sJHtwYXJhbXN9YFxuICBjb25zdCBtZXNzYWdlQnl0ZXMgPSBldGhlcnMudG9VdGY4Qnl0ZXMobWVzc2FnZSlcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbmVyLnNpZ25NZXNzYWdlKG1lc3NhZ2VCeXRlcylcbiAgcmV0dXJuIHNpZ25hdHVyZVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBub25jZSBmb3Igc2VydmljZSBmdW5jdGlvbnMgKGFzeW5jIG5vbmNlKVxuICogVXNlcyB0aW1lc3RhbXAgKyByYW5kb20gbnVtYmVyIHRvIGVuc3VyZSB1bmlxdWVuZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVNlcnZpY2VOb25jZSgpOiBiaWdpbnQge1xuICBjb25zdCB0aW1lc3RhbXAgPSBCaWdJbnQoRGF0ZS5ub3coKSlcbiAgY29uc3QgcmFuZG9tID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApKVxuICByZXR1cm4gdGltZXN0YW1wICogQmlnSW50KDEwMDAwMDApICsgcmFuZG9tXG59XG5cbi8qKlxuICogQ3JlYXRlcyBnYXNsZXNzIHJlZ2lzdHJhdGlvbiBkYXRhIHdpdGggYm90aCBzZXJ2aWNlIGFuZCBFVlZNIHBheW1lbnQgc2lnbmF0dXJlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlR2FzbGVzc1JlZ2lzdHJhdGlvbihcbiAgc2lnbmVyOiBldGhlcnMuU2lnbmVyLFxuICBldnZtSUQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBkdXJhdGlvbjogYmlnaW50LFxuICByZXNvbHZlcjogc3RyaW5nLFxuICBtZXRhZGF0YTogc3RyaW5nLFxuICBhbW91bnQ6IGJpZ2ludCxcbiAgcHJpb3JpdHlGZWU6IGJpZ2ludCxcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIHByb3ZpZGVyOiBldGhlcnMuUHJvdmlkZXIsXG4gIGV2dm1BZGRyZXNzOiBzdHJpbmdcbikge1xuICBjb25zdCB1c2VyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKClcbiAgXG4gIC8vIDEuIEdlbmVyYXRlIHNlcnZpY2Ugbm9uY2UgKGFzeW5jIG5vbmNlIC0gY2FuIGJlIGFueSB1bnVzZWQgbnVtYmVyKVxuICBjb25zdCBzZXJ2aWNlTm9uY2UgPSBnZW5lcmF0ZVNlcnZpY2VOb25jZSgpXG4gIFxuICAvLyAyLiBDcmVhdGUgc2VydmljZSBzaWduYXR1cmVcbiAgLy8gRm9ybWF0OiBcIjxldnZtSUQ+LHJlZ2lzdGVyR2FzbGVzcyw8bmFtZT4sPGR1cmF0aW9uPiw8YW1vdW50Piw8bm9uY2U+XCJcbiAgY29uc3Qgc2VydmljZVBhcmFtcyA9IGAke25hbWV9LCR7ZHVyYXRpb24udG9TdHJpbmcoKX0sJHthbW91bnQudG9TdHJpbmcoKX0sJHtzZXJ2aWNlTm9uY2UudG9TdHJpbmcoKX1gXG4gIGNvbnN0IHNlcnZpY2VTaWduYXR1cmUgPSBhd2FpdCBzaWduU2VydmljZUZ1bmN0aW9uKFxuICAgIHNpZ25lcixcbiAgICBldnZtSUQsXG4gICAgJ3JlZ2lzdGVyR2FzbGVzcycsXG4gICAgc2VydmljZVBhcmFtc1xuICApXG4gIFxuICAvLyAzLiBHZXQgRVZWTSBwYXltZW50IG5vbmNlIChzeW5jIG5vbmNlIC0gbXVzdCBiZSBzZXF1ZW50aWFsKVxuICBjb25zdCBldnZtTm9uY2UgPSBhd2FpdCBnZXROZXh0Tm9uY2UocHJvdmlkZXIsIGV2dm1BZGRyZXNzLCB1c2VyQWRkcmVzcylcbiAgXG4gIC8vIDQuIENyZWF0ZSBFVlZNIHBheW1lbnQgc2lnbmF0dXJlXG4gIGNvbnN0IGV2dm1TaWduYXR1cmUgPSBhd2FpdCBzaWduRXZ2bVBheShcbiAgICBzaWduZXIsXG4gICAgZXZ2bUlELFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gUHJpbmNpcGFsIHRva2VuIChNQVRFKVxuICAgIGFtb3VudCxcbiAgICBwcmlvcml0eUZlZSxcbiAgICBldnZtTm9uY2UsXG4gICAgZmFsc2UsIC8vIHByaW9yaXR5RmxhZyBmb3IgRVZWTSBwYXltZW50XG4gICAgY29udHJhY3RBZGRyZXNzXG4gIClcblxuICByZXR1cm4ge1xuICAgIGZ1bmN0aW9uTmFtZTogJ3JlZ2lzdGVyR2FzbGVzcycsXG4gICAgYXJnczogW1xuICAgICAgbmFtZSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgcmVzb2x2ZXIsXG4gICAgICBtZXRhZGF0YSxcbiAgICAgIHVzZXJBZGRyZXNzLFxuICAgICAgYW1vdW50LFxuICAgICAgc2VydmljZU5vbmNlLCAgICAgICAgLy8gU2VydmljZSBub25jZVxuICAgICAgc2VydmljZVNpZ25hdHVyZSwgICAgLy8gU2VydmljZSBzaWduYXR1cmVcbiAgICAgIHByaW9yaXR5RmVlLCAgICAgICAgIC8vIEVWVk0gcHJpb3JpdHkgZmVlXG4gICAgICBldnZtTm9uY2UsICAgICAgICAgICAvLyBFVlZNIHBheW1lbnQgbm9uY2VcbiAgICAgIGZhbHNlLCAgICAgICAgICAgICAgIC8vIEVWVk0gcHJpb3JpdHkgZmxhZ1xuICAgICAgZXZ2bVNpZ25hdHVyZSwgICAgICAgLy8gRVZWTSBwYXltZW50IHNpZ25hdHVyZVxuICAgIF0sXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGdhc2xlc3MgcmVuZXdhbCBkYXRhIHdpdGggYm90aCBzZXJ2aWNlIGFuZCBFVlZNIHBheW1lbnQgc2lnbmF0dXJlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlR2FzbGVzc1JlbmV3YWwoXG4gIHNpZ25lcjogZXRoZXJzLlNpZ25lcixcbiAgZXZ2bUlEOiBzdHJpbmcsXG4gIG5hbWVIYXNoOiBzdHJpbmcsXG4gIGR1cmF0aW9uOiBiaWdpbnQsXG4gIGFtb3VudDogYmlnaW50LFxuICBwcmlvcml0eUZlZTogYmlnaW50LFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgcHJvdmlkZXI6IGV0aGVycy5Qcm92aWRlcixcbiAgZXZ2bUFkZHJlc3M6IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHVzZXJBZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKVxuICBcbiAgLy8gMS4gR2VuZXJhdGUgc2VydmljZSBub25jZVxuICBjb25zdCBzZXJ2aWNlTm9uY2UgPSBnZW5lcmF0ZVNlcnZpY2VOb25jZSgpXG4gIFxuICAvLyAyLiBDcmVhdGUgc2VydmljZSBzaWduYXR1cmVcbiAgLy8gRm9ybWF0OiBcIjxldnZtSUQ+LHJlbmV3R2FzbGVzcyw8bmFtZUhhc2g+LDxkdXJhdGlvbj4sPGFtb3VudD4sPG5vbmNlPlwiXG4gIGNvbnN0IHNlcnZpY2VQYXJhbXMgPSBgJHtuYW1lSGFzaH0sJHtkdXJhdGlvbi50b1N0cmluZygpfSwke2Ftb3VudC50b1N0cmluZygpfSwke3NlcnZpY2VOb25jZS50b1N0cmluZygpfWBcbiAgY29uc3Qgc2VydmljZVNpZ25hdHVyZSA9IGF3YWl0IHNpZ25TZXJ2aWNlRnVuY3Rpb24oXG4gICAgc2lnbmVyLFxuICAgIGV2dm1JRCxcbiAgICAncmVuZXdHYXNsZXNzJyxcbiAgICBzZXJ2aWNlUGFyYW1zXG4gIClcbiAgXG4gIC8vIDMuIEdldCBFVlZNIHBheW1lbnQgbm9uY2VcbiAgY29uc3QgZXZ2bU5vbmNlID0gYXdhaXQgZ2V0TmV4dE5vbmNlKHByb3ZpZGVyLCBldnZtQWRkcmVzcywgdXNlckFkZHJlc3MpXG4gIFxuICAvLyA0LiBDcmVhdGUgRVZWTSBwYXltZW50IHNpZ25hdHVyZVxuICBjb25zdCBldnZtU2lnbmF0dXJlID0gYXdhaXQgc2lnbkV2dm1QYXkoXG4gICAgc2lnbmVyLFxuICAgIGV2dm1JRCxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gICAgYW1vdW50LFxuICAgIHByaW9yaXR5RmVlLFxuICAgIGV2dm1Ob25jZSxcbiAgICBmYWxzZSxcbiAgICBjb250cmFjdEFkZHJlc3NcbiAgKVxuXG4gIHJldHVybiB7XG4gICAgZnVuY3Rpb25OYW1lOiAncmVuZXdHYXNsZXNzJyxcbiAgICBhcmdzOiBbXG4gICAgICBuYW1lSGFzaCxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdXNlckFkZHJlc3MsXG4gICAgICBhbW91bnQsXG4gICAgICBzZXJ2aWNlTm9uY2UsXG4gICAgICBzZXJ2aWNlU2lnbmF0dXJlLFxuICAgICAgcHJpb3JpdHlGZWUsXG4gICAgICBldnZtTm9uY2UsXG4gICAgICBmYWxzZSxcbiAgICAgIGV2dm1TaWduYXR1cmUsXG4gICAgXSxcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgZ2FzbGVzcyB0cmFuc2ZlciBkYXRhIHdpdGggc2VydmljZSBzaWduYXR1cmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUdhc2xlc3NUcmFuc2ZlcihcbiAgc2lnbmVyOiBldGhlcnMuU2lnbmVyLFxuICBldnZtSUQ6IHN0cmluZyxcbiAgbmFtZUhhc2g6IHN0cmluZyxcbiAgbmV3T3duZXI6IHN0cmluZyxcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmdcbikge1xuICBjb25zdCB1c2VyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKClcbiAgXG4gIC8vIDEuIEdlbmVyYXRlIHNlcnZpY2Ugbm9uY2VcbiAgY29uc3Qgc2VydmljZU5vbmNlID0gZ2VuZXJhdGVTZXJ2aWNlTm9uY2UoKVxuICBcbiAgLy8gMi4gQ3JlYXRlIHNlcnZpY2Ugc2lnbmF0dXJlXG4gIC8vIEZvcm1hdDogXCI8ZXZ2bUlEPix0cmFuc2Zlckdhc2xlc3MsPG5hbWVIYXNoPiw8bmV3T3duZXI+LDxub25jZT5cIlxuICBjb25zdCBzZXJ2aWNlUGFyYW1zID0gYCR7bmFtZUhhc2h9LCR7bmV3T3duZXJ9LCR7c2VydmljZU5vbmNlLnRvU3RyaW5nKCl9YFxuICBjb25zdCBzZXJ2aWNlU2lnbmF0dXJlID0gYXdhaXQgc2lnblNlcnZpY2VGdW5jdGlvbihcbiAgICBzaWduZXIsXG4gICAgZXZ2bUlELFxuICAgICd0cmFuc2Zlckdhc2xlc3MnLFxuICAgIHNlcnZpY2VQYXJhbXNcbiAgKVxuXG4gIHJldHVybiB7XG4gICAgZnVuY3Rpb25OYW1lOiAndHJhbnNmZXJHYXNsZXNzJyxcbiAgICBhcmdzOiBbXG4gICAgICBuYW1lSGFzaCxcbiAgICAgIG5ld093bmVyLFxuICAgICAgdXNlckFkZHJlc3MsXG4gICAgICBzZXJ2aWNlTm9uY2UsXG4gICAgICBzZXJ2aWNlU2lnbmF0dXJlLFxuICAgIF0sXG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuZXh0IHN5bmMgbm9uY2UgZm9yIEVWVk0gcGF5bWVudHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE5leHROb25jZShwcm92aWRlcjogZXRoZXJzLlByb3ZpZGVyLCBldnZtQWRkcmVzczogc3RyaW5nLCB1c2VyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxiaWdpbnQ+IHtcbiAgY29uc3QgZXZ2bUFiaSA9IFsnZnVuY3Rpb24gZ2V0TmV4dEN1cnJlbnRTeW5jTm9uY2UoYWRkcmVzcyB1c2VyKSB2aWV3IHJldHVybnMgKHVpbnQyNTYpJ11cbiAgY29uc3QgZXZ2bUNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChldnZtQWRkcmVzcywgZXZ2bUFiaSwgcHJvdmlkZXIpXG4gIHJldHVybiBldnZtQ29udHJhY3QuZ2V0TmV4dEN1cnJlbnRTeW5jTm9uY2UodXNlckFkZHJlc3MpXG59XG5cbi8qKlxuICogR2V0cyB0aGUgRVZWTSBJRCAocmV0dXJucyBhcyBzdHJpbmcgZm9yIGNvbXBhdGliaWxpdHkpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFdnZtSUQocHJvdmlkZXI6IGV0aGVycy5Qcm92aWRlciwgZXZ2bUFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIC8vIFRyeSB1aW50MjU2IGZpcnN0IChuZXcgZm9ybWF0KSwgZmFsbGJhY2sgdG8gc3RyaW5nIChvbGQgZm9ybWF0KVxuICB0cnkge1xuICAgIGNvbnN0IGV2dm1BYmkgPSBbJ2Z1bmN0aW9uIGdldEV2dm1JRCgpIHZpZXcgcmV0dXJucyAodWludDI1NiknXVxuICAgIGNvbnN0IGV2dm1Db250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoZXZ2bUFkZHJlc3MsIGV2dm1BYmksIHByb3ZpZGVyKVxuICAgIGNvbnN0IGlkID0gYXdhaXQgZXZ2bUNvbnRyYWN0LmdldEV2dm1JRCgpXG4gICAgLy8gUmV0dXJuIHRoZSBJRCBhcyBzdHJpbmcsIGV2ZW4gaWYgaXQncyAwXG4gICAgLy8gTm90ZTogRVZWTSBJRCBvZiAwIG1lYW5zIHRoZSBjb250cmFjdCBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkXG4gICAgcmV0dXJuIGlkLnRvU3RyaW5nKClcbiAgfSBjYXRjaCB7XG4gICAgLy8gRmFsbGJhY2sgdG8gc3RyaW5nIGZvcm1hdCBmb3Igb2xkZXIgY29udHJhY3RzXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2dm1BYmkgPSBbJ2Z1bmN0aW9uIGdldEV2dm1JRCgpIHZpZXcgcmV0dXJucyAoc3RyaW5nKSddXG4gICAgICBjb25zdCBldnZtQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGV2dm1BZGRyZXNzLCBldnZtQWJpLCBwcm92aWRlcilcbiAgICAgIGNvbnN0IGlkID0gYXdhaXQgZXZ2bUNvbnRyYWN0LmdldEV2dm1JRCgpXG4gICAgICByZXR1cm4gaWRcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIElmIGFsbCBlbHNlIGZhaWxzLCByZXR1cm4gXCIwXCIgYXMgZGVmYXVsdCAobWF0Y2hlcyBjb250cmFjdCBiZWhhdmlvcilcbiAgICAgIC8vIFRoaXMgaW5kaWNhdGVzIHRoZSBFVlZNIGNvbnRyYWN0IGhhc24ndCBiZWVuIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBcIjBcIlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHNlcnZpY2Ugbm9uY2UgaGFzIGJlZW4gdXNlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNTZXJ2aWNlTm9uY2VVc2VkKFxuICBwcm92aWRlcjogZXRoZXJzLlByb3ZpZGVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgdXNlckFkZHJlc3M6IHN0cmluZyxcbiAgbm9uY2U6IGJpZ2ludFxuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IGFiaSA9IFsnZnVuY3Rpb24gaXNTZXJ2aWNlTm9uY2VVc2VkKGFkZHJlc3MgdXNlciwgdWludDI1NiBub25jZSkgdmlldyByZXR1cm5zIChib29sKSddXG4gIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgcHJvdmlkZXIpXG4gIHJldHVybiBjb250cmFjdC5pc1NlcnZpY2VOb25jZVVzZWQodXNlckFkZHJlc3MsIG5vbmNlKVxufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIGNvbnRyYWN0IGhhcyB0aGUgdXBkYXRlZCByZWdpc3Rlckdhc2xlc3MgZnVuY3Rpb25cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJhY3QgaGFzIHRoZSBuZXcgc2lnbmF0dXJlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUNvbnRyYWN0SGFzVXBkYXRlZEZ1bmN0aW9uKFxuICBwcm92aWRlcjogZXRoZXJzLlByb3ZpZGVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZ1xuKTogUHJvbWlzZTx7IGhhc1VwZGF0ZWRGdW5jdGlvbjogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICB0cnkge1xuICAgIC8vIFRyeSB0byBjYWxsIHRoZSBuZXcgZnVuY3Rpb24gc2lnbmF0dXJlIHdpdGggZXN0aW1hdGVHYXNcbiAgICAvLyBUaGlzIHdpbGwgZmFpbCBpZiB0aGUgZnVuY3Rpb24gZG9lc24ndCBleGlzdCBvciBoYXMgd3Jvbmcgc2lnbmF0dXJlXG4gICAgY29uc3QgYWJpID0gW1xuICAgICAgJ2Z1bmN0aW9uIHJlZ2lzdGVyR2FzbGVzcyhzdHJpbmcgbmFtZSwgdWludDI1NiBkdXJhdGlvbiwgYWRkcmVzcyByZXNvbHZlciwgc3RyaW5nIG1ldGFkYXRhLCBhZGRyZXNzIHVzZXIsIHVpbnQyNTYgYW1vdW50LCB1aW50MjU2IG5vbmNlLCBieXRlcyBzaWduYXR1cmUsIHVpbnQyNTYgcHJpb3JpdHlGZWVfRVZWTSwgdWludDI1NiBub25jZV9FVlZNLCBib29sIHByaW9yaXR5RmxhZ19FVlZNLCBieXRlcyBzaWduYXR1cmVfRVZWTSknXG4gICAgXVxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgcHJvdmlkZXIpXG4gICAgXG4gICAgLy8gVHJ5IHRvIGVzdGltYXRlIGdhcyB3aXRoIGR1bW15IHBhcmFtZXRlcnNcbiAgICAvLyBJZiB0aGUgZnVuY3Rpb24gZXhpc3RzLCB0aGlzIHdpbGwgd29yayAoZXZlbiBpZiBpdCByZXZlcnRzIGZvciBvdGhlciByZWFzb25zKVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb250cmFjdC5yZWdpc3Rlckdhc2xlc3MuZXN0aW1hdGVHYXMoXG4gICAgICAgICd0ZXN0JyxcbiAgICAgICAgQmlnSW50KDM2NSAqIDI0ICogNjAgKiA2MCksXG4gICAgICAgIGV0aGVycy5aZXJvQWRkcmVzcyxcbiAgICAgICAgJ3t9JyxcbiAgICAgICAgZXRoZXJzLlplcm9BZGRyZXNzLFxuICAgICAgICBCaWdJbnQoMCksXG4gICAgICAgIEJpZ0ludCgwKSxcbiAgICAgICAgJzB4JyxcbiAgICAgICAgQmlnSW50KDApLFxuICAgICAgICBCaWdJbnQoMCksXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnMHgnXG4gICAgICApXG4gICAgICByZXR1cm4geyBoYXNVcGRhdGVkRnVuY3Rpb246IHRydWUgfVxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAvLyBJZiBpdCdzIGEgc2lnbmF0dXJlIG1pc21hdGNoLCB0aGUgZnVuY3Rpb24gZG9lc24ndCBleGlzdFxuICAgICAgaWYgKGVycj8uY29kZSA9PT0gJ0NBTExfRVhDRVBUSU9OJyAmJiBlcnI/LmRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgaGFzVXBkYXRlZEZ1bmN0aW9uOiBmYWxzZSwgXG4gICAgICAgICAgZXJyb3I6ICdDb250cmFjdCBkb2VzIG5vdCBoYXZlIHRoZSB1cGRhdGVkIHJlZ2lzdGVyR2FzbGVzcyBmdW5jdGlvbi4gUGxlYXNlIHJlZGVwbG95IHRoZSBjb250cmFjdCB3aXRoIHRoZSBuZXcgY29kZS4nIFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBPdGhlciBlcnJvcnMgKGxpa2UgcmV2ZXJ0KSBtZWFuIHRoZSBmdW5jdGlvbiBleGlzdHMgYnV0IGZhaWxlZCBmb3Igb3RoZXIgcmVhc29uc1xuICAgICAgcmV0dXJuIHsgaGFzVXBkYXRlZEZ1bmN0aW9uOiB0cnVlIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgcmV0dXJuIHsgXG4gICAgICBoYXNVcGRhdGVkRnVuY3Rpb246IGZhbHNlLCBcbiAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHZlcmlmeSBjb250cmFjdDogJHtlcnI/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWAgXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2lnbnMgYSB0cmFuc2FjdGlvbiByZXF1ZXN0IGZvciB0aGUgcmVsYXllclxuICogVGhpcyBzaWduYXR1cmUgcHJvdmVzIHRoZSB1c2VyIGF1dGhvcml6ZWQgc2VuZGluZyB0aGlzIHRyYW5zYWN0aW9uIHRvIHRoZSByZWxheWVyXG4gKiBGb3JtYXQ6IFwiPHVzZXJBZGRyZXNzPiw8Y29udHJhY3RBZGRyZXNzPiw8ZnVuY3Rpb25OYW1lPiw8YXJnc0hhc2g+LDxub25jZT5cIlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uUmVxdWVzdChcbiAgc2lnbmVyOiBldGhlcnMuU2lnbmVyLFxuICB1c2VyQWRkcmVzczogc3RyaW5nLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZnVuY3Rpb25OYW1lOiBzdHJpbmcsXG4gIGFyZ3M6IGFueVtdLFxuICBub25jZTogYmlnaW50XG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAvLyBDcmVhdGUgYSBtZXNzYWdlIHRoYXQgaW5jbHVkZXMgYWxsIHRyYW5zYWN0aW9uIGRldGFpbHNcbiAgLy8gQ29udmVydCBhcmdzIHRvIGEgY29uc2lzdGVudCBmb3JtYXQgZm9yIGhhc2hpbmdcbiAgY29uc3Qgbm9ybWFsaXplZEFyZ3MgPSBhcmdzLm1hcChhcmcgPT4ge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnYmlnaW50Jykge1xuICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpXG4gICAgfVxuICAgIHJldHVybiBhcmdcbiAgfSlcbiAgY29uc3QgYXJnc0hhc2ggPSBldGhlcnMua2VjY2FrMjU2KGV0aGVycy50b1V0ZjhCeXRlcyhKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQXJncykpKVxuICBjb25zdCBtZXNzYWdlID0gYCR7dXNlckFkZHJlc3N9LCR7Y29udHJhY3RBZGRyZXNzfSwke2Z1bmN0aW9uTmFtZX0sJHthcmdzSGFzaH0sJHtub25jZS50b1N0cmluZygpfWBcbiAgY29uc3QgbWVzc2FnZUJ5dGVzID0gZXRoZXJzLnRvVXRmOEJ5dGVzKG1lc3NhZ2UpXG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduTWVzc2FnZShtZXNzYWdlQnl0ZXMpXG4gIHJldHVybiBzaWduYXR1cmVcbn1cblxuLyoqXG4gKiBTZW5kcyB0cmFuc2FjdGlvbiB0byByZWxheWVyIHNlcnZpY2VcbiAqIFRoZSByZWxheWVyIHdpbGwgc3VibWl0IHRoZSB0cmFuc2FjdGlvbiBvbiBiZWhhbGYgb2YgdGhlIHVzZXIgKHBheWluZyBnYXMpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kVG9SZWxheWVyKFxuICByZWxheWVyVXJsOiBzdHJpbmcsXG4gIHVzZXJBZGRyZXNzOiBzdHJpbmcsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBmdW5jdGlvbk5hbWU6IHN0cmluZyxcbiAgYXJnczogYW55W10sXG4gIHNlcnZpY2VOb25jZTogYmlnaW50LFxuICBzaWduZXI6IGV0aGVycy5TaWduZXJcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIC8vIFNpZ24gdGhlIHRyYW5zYWN0aW9uIHJlcXVlc3QgZm9yIHJlbGF5ZXIgdmFsaWRhdGlvblxuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduVHJhbnNhY3Rpb25SZXF1ZXN0KFxuICAgIHNpZ25lcixcbiAgICB1c2VyQWRkcmVzcyxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgZnVuY3Rpb25OYW1lLFxuICAgIGFyZ3MsXG4gICAgc2VydmljZU5vbmNlXG4gIClcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3JlbGF5ZXJVcmx9L2FwaS9zdWJtaXRgLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdXNlckFkZHJlc3MsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICBhcmdzOiBhcmdzLm1hcChhcmcgPT4ge1xuICAgICAgICAvLyBDb252ZXJ0IGJpZ2ludCB0byBzdHJpbmcgZm9yIEpTT04gc2VyaWFsaXphdGlvblxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICByZXR1cm4gYXJnLnRvU3RyaW5nKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnXG4gICAgICB9KSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIG5vbmNlOiBzZXJ2aWNlTm9uY2UudG9TdHJpbmcoKSxcbiAgICB9KSxcbiAgfSlcbiAgXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZXJyb3I6IHJlc3BvbnNlLnN0YXR1c1RleHQgfSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBSZWxheWVyIGVycm9yOiAke2Vycm9yRGF0YS5lcnJvciB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gIH1cbiAgXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbGF5ZXIgZXJyb3I6ICR7ZGF0YS5lcnJvciB8fCAnVHJhbnNhY3Rpb24gc3VibWlzc2lvbiBmYWlsZWQnfWApXG4gIH1cbiAgXG4gIHJldHVybiBkYXRhLnR4SGFzaFxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9NRVRBREFUQSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgdHlwZTogJ2hlYWx0aGNhcmUtcHJvdmlkZXInLFxuICBzcGVjaWFsdHk6ICdnZW5lcmFsJyxcbn0pXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFU09MVkVSID0gZXRoZXJzLlplcm9BZGRyZXNzXG5leHBvcnQgY29uc3QgWkVST19BRERSRVNTID0gZXRoZXJzLlplcm9BZGRyZXNzXG5leHBvcnQgY29uc3QgTkFNRV9TVUZGSVggPSAnLm1vdHVzJ1xuZXhwb3J0IGNvbnN0IEJBU0VfUEFZTUVOVF9UT0tFTiA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnXG5leHBvcnQgY29uc3QgQ09OVFJBQ1RfRkFMTEJBQ0sgPSBDT05UUkFDVF9BRERSRVNTXG4iXSwibmFtZXMiOlsiZXRoZXJzIiwiQ09OVFJBQ1RfQUREUkVTUyIsIkVWVk1fQUREUkVTUyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19FVlZNX0FERFJFU1MiLCJFVlZNX0lEIiwiTkVYVF9QVUJMSUNfRVZWTV9JRCIsIlJFTEFZRVJfVVJMIiwiTkVYVF9QVUJMSUNfUkVMQVlFUl9VUkwiLCJjaGVja1JlbGF5ZXJIZWFsdGgiLCJyZWxheWVyVXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJvayIsImF2YWlsYWJsZSIsImVycm9yIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJtZXNzYWdlIiwic2lnbkV2dm1QYXkiLCJzaWduZXIiLCJldnZtSUQiLCJ0b0FkZHJlc3MiLCJ0b2tlbiIsImFtb3VudCIsInByaW9yaXR5RmVlIiwibm9uY2UiLCJwcmlvcml0eUZsYWciLCJleGVjdXRvciIsImZvcm1hdEFkZHJlc3MiLCJhZGRyIiwidG9Mb3dlckNhc2UiLCJpbnB1dHMiLCJ0b1N0cmluZyIsIm1lc3NhZ2VCeXRlcyIsInRvVXRmOEJ5dGVzIiwic2lnbmF0dXJlIiwic2lnbk1lc3NhZ2UiLCJzaWduU2VydmljZUZ1bmN0aW9uIiwiZnVuY3Rpb25OYW1lIiwicGFyYW1zIiwiZ2VuZXJhdGVTZXJ2aWNlTm9uY2UiLCJ0aW1lc3RhbXAiLCJCaWdJbnQiLCJEYXRlIiwibm93IiwicmFuZG9tIiwiTWF0aCIsImZsb29yIiwiY3JlYXRlR2FzbGVzc1JlZ2lzdHJhdGlvbiIsIm5hbWUiLCJkdXJhdGlvbiIsInJlc29sdmVyIiwibWV0YWRhdGEiLCJjb250cmFjdEFkZHJlc3MiLCJwcm92aWRlciIsImV2dm1BZGRyZXNzIiwidXNlckFkZHJlc3MiLCJnZXRBZGRyZXNzIiwic2VydmljZU5vbmNlIiwic2VydmljZVBhcmFtcyIsInNlcnZpY2VTaWduYXR1cmUiLCJldnZtTm9uY2UiLCJnZXROZXh0Tm9uY2UiLCJldnZtU2lnbmF0dXJlIiwiYXJncyIsImNyZWF0ZUdhc2xlc3NSZW5ld2FsIiwibmFtZUhhc2giLCJjcmVhdGVHYXNsZXNzVHJhbnNmZXIiLCJuZXdPd25lciIsImV2dm1BYmkiLCJldnZtQ29udHJhY3QiLCJDb250cmFjdCIsImdldE5leHRDdXJyZW50U3luY05vbmNlIiwiZ2V0RXZ2bUlEIiwiaWQiLCJpc1NlcnZpY2VOb25jZVVzZWQiLCJhYmkiLCJjb250cmFjdCIsInZlcmlmeUNvbnRyYWN0SGFzVXBkYXRlZEZ1bmN0aW9uIiwicmVnaXN0ZXJHYXNsZXNzIiwiZXN0aW1hdGVHYXMiLCJaZXJvQWRkcmVzcyIsImhhc1VwZGF0ZWRGdW5jdGlvbiIsImVyciIsImNvZGUiLCJzaWduVHJhbnNhY3Rpb25SZXF1ZXN0Iiwibm9ybWFsaXplZEFyZ3MiLCJtYXAiLCJhcmciLCJhcmdzSGFzaCIsImtlY2NhazI1NiIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZW5kVG9SZWxheWVyIiwiYm9keSIsImVycm9yRGF0YSIsImNhdGNoIiwic3RhdHVzVGV4dCIsIkVycm9yIiwic3VjY2VzcyIsInR4SGFzaCIsIkRFRkFVTFRfTUVUQURBVEEiLCJ0eXBlIiwic3BlY2lhbHR5IiwiREVGQVVMVF9SRVNPTFZFUiIsIlpFUk9fQUREUkVTUyIsIk5BTUVfU1VGRklYIiwiQkFTRV9QQVlNRU5UX1RPS0VOIiwiQ09OVFJBQ1RfRkFMTEJBQ0siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/evvm.ts\n"));

/***/ })

});